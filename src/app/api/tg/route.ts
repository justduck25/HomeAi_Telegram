import { NextRequest, NextResponse } from "next/server";
import { GoogleGenerativeAI, type Content } from "@google/generative-ai";
import { mongodb, type ContextMessage } from "@/lib/mongodb";
import { textToSpeech, sendVoiceMessage, sendRecordingAction, isTextSuitableForTTS } from "@/lib/text-to-speech";

// Admin configuration
const ADMIN_USER_ID = 539971498;

// S·ª≠ d·ª•ng Node.js runtime ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi SDK
export const runtime = "nodejs";

// Function ki·ªÉm tra quy·ªÅn admin
function isAdmin(userId: number | undefined): boolean {
  return userId === ADMIN_USER_ID;
}

// H√†m t√¨m ki·∫øm web v·ªõi Google Custom Search API
async function searchWeb(query: string, includeImages: boolean = false): Promise<{ text: string | null; images: string[] }> {
  const apiKey = process.env.GOOGLE_SEARCH_API_KEY;
  const searchEngineId = process.env.GOOGLE_SEARCH_ENGINE_ID;
  
  if (!apiKey || !searchEngineId) {
    console.log("Google Search API ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh");
    return { text: null, images: [] };
  }

  try {
    // T√¨m ki·∫øm text
    const searchUrl = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}&num=5&lr=lang_vi`;
    
    const response = await fetch(searchUrl);
    const data = await response.json();
    
    let searchResults = null;
    let images: string[] = [];
    
    if (response.ok && data.items && data.items.length > 0) {
      // Format k·∫øt qu·∫£ search
      searchResults = `üîç **K·∫øt qu·∫£ t√¨m ki·∫øm cho "${query}":**\n\n`;
      
      data.items.slice(0, 3).forEach((item: { title: string; snippet: string; link: string }, index: number) => {
        searchResults! += `**${index + 1}. ${item.title}**\n`;
        searchResults! += `${item.snippet}\n`;
        searchResults! += `üîó ${item.link}\n\n`;
      });
    }
    
    // T√¨m ki·∫øm h√¨nh ·∫£nh n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
    if (includeImages) {
      try {
        const imageSearchUrl = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}&searchType=image&num=3&lr=lang_vi`;
        const imageResponse = await fetch(imageSearchUrl);
        const imageData = await imageResponse.json();
        
        if (imageResponse.ok && imageData.items && imageData.items.length > 0) {
          images = imageData.items.map((item: { link: string }) => item.link).slice(0, 3);
        }
      } catch (error) {
        console.error("L·ªói t√¨m ki·∫øm h√¨nh ·∫£nh:", error);
      }
    }
    
    return { text: searchResults, images };
  } catch (error) {
    console.error("L·ªói t√¨m ki·∫øm web:", error);
    return { text: null, images: [] };
  }
}

// H√†m ki·ªÉm tra xem c√≥ c·∫ßn t√¨m ki·∫øm web kh√¥ng
function shouldSearchWeb(text: string): boolean {
  const searchKeywords = [
    // T·ª´ kh√≥a t√¨m ki·∫øm tr·ª±c ti·∫øp
    't√¨m ki·∫øm', 'search', 't√¨m', 'ki·∫øm', 'tra c·ª©u', 'research', 'nghi√™n c·ª©u',
    
    // Tin t·ª©c & th·ªùi s·ª±
    'tin t·ª©c', 'tin m·ªõi', 'th·ªùi s·ª±', 'b√°o ch√≠', 's·ª± ki·ªán',
    'm·ªõi nh·∫•t', 'c·∫≠p nh·∫≠t', 'hi·ªán t·∫°i', 'h√¥m nay', 'tu·∫ßn n√†y',
    
    // Gi√° c·∫£ & th·ªã tr∆∞·ªùng
    'gi√°', 'bao nhi√™u ti·ªÅn', 'chi ph√≠', 'th·ªã tr∆∞·ªùng', 'c·ªï phi·∫øu',
    'bitcoin', 'v√†ng', 'USD', 't·ª∑ gi√°', 'gi√° c·∫£',
    
    // Th√¥ng tin s·∫£n ph·∫©m
    'mua', 'b√°n', 's·∫£n ph·∫©m', 'review', 'ƒë√°nh gi√°',
    'so s√°nh', 't·ªët nh·∫•t', 'khuy·∫øn m√£i', '∆∞u ƒë√£i',
    
    // Th√¥ng tin h·ªçc t·∫≠p
    'h·ªçc', 'tr∆∞·ªùng', 'ƒë·∫°i h·ªçc', 'kh√≥a h·ªçc', 'thi c·ª≠',
    'tuy·ªÉn sinh', 'h·ªçc b·ªïng', 'gi√°o d·ª•c',
    
    // Th·ªùi ti·∫øt & ƒë·ªãa ƒëi·ªÉm
    'th·ªùi ti·∫øt', 'nhi·ªát ƒë·ªô', 'm∆∞a', 'n·∫Øng', 'b√£o',
    'ƒë∆∞·ªùng ƒëi', 'ƒë·ªãa ch·ªâ', 'qu√°n ƒÉn', 'nh√† h√†ng', 'du l·ªãch',
    
    // S·ª± ki·ªán & gi·∫£i tr√≠
    'phim', 'nh·∫°c', 'ca sƒ©', 'di·ªÖn vi√™n', 'concert',
    'l·ªÖ h·ªôi', 's·ª± ki·ªán', 'tri·ªÉn l√£m', 'show',
    
    // Th·ªÉ thao
    'b√≥ng ƒë√°', 'world cup', 'euro', 'sea games', 'olympic',
    'th·ªÉ thao', 't·ª∑ s·ªë', 'k·∫øt qu·∫£'
  ];
  
  const lowerText = text.toLowerCase();
  return searchKeywords.some(keyword => lowerText.includes(keyword));
}

// H√†m ki·ªÉm tra xem c√≥ c·∫ßn t√¨m ki·∫øm h√¨nh ·∫£nh kh√¥ng
function shouldSearchImages(text: string): boolean {
  const imageKeywords = [
    'h√¨nh ·∫£nh', '·∫£nh', 'photo', 'picture', 'image',
    'xem ·∫£nh', 'cho xem', 'hi·ªÉn th·ªã', 'show me',
    'nh∆∞ th·∫ø n√†o', 'tr√¥ng ra sao', 'h√¨nh d√°ng'
  ];
  
  const lowerText = text.toLowerCase();
  return imageKeywords.some(keyword => lowerText.includes(keyword));
}

// H√†m ki·ªÉm tra tin nh·∫Øn ch√†o h·ªèi
function isGreeting(text: string): boolean {
  const greetings = [
    'xin ch√†o', 'ch√†o', 'hello', 'hi', 'hey',
    'ch√†o b·∫°n', 'ch√†o bot', 'b·∫°n kh·ªèe kh√¥ng',
    'c√≥ ai kh√¥ng', 'alo', 'h·∫ø l√¥'
  ];
  
  const lowerText = text.toLowerCase().trim();
  return greetings.some(greeting => 
    lowerText === greeting || 
    lowerText.startsWith(greeting + ' ') ||
    lowerText.endsWith(' ' + greeting)
  );
}

// H√†m ki·ªÉm tra c√¢u h·ªèi v·ªÅ ngu·ªìn g·ªëc AI
function isAskingAboutOrigin(text: string): boolean {
  const originKeywords = [
    'ai t·∫°o ra b·∫°n', 'ai l√†m ra b·∫°n', 'ai ph√°t tri·ªÉn b·∫°n',
    'b·∫°n ƒë∆∞·ª£c t·∫°o b·ªüi ai', 'b·∫°n ƒë∆∞·ª£c l√†m b·ªüi ai', 'b·∫°n ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi ai',
    'ngu·ªìn g·ªëc', 'xu·∫•t x·ª©', 't√°c gi·∫£', 'ng∆∞·ªùi t·∫°o',
    'who created you', 'who made you', 'who developed you',
    'created by', 'made by', 'developed by',
    'bot n√†y c·ªßa ai', 'ai s·ªü h·ªØu bot n√†y', 'ch·ªß s·ªü h·ªØu bot',
    'justduck', 't√°c gi·∫£ bot', 'ng∆∞·ªùi vi·∫øt bot'
  ];
  
  const lowerText = text.toLowerCase();
  return originKeywords.some(keyword => lowerText.includes(keyword));
}

// H√†m t·∫°o danh s√°ch l·ªánh
function getCommandsList(userId?: number): string {
  let commands = `ü§ñ **Danh s√°ch l·ªánh c·ªßa bot:**\n\n` +
    `üìù **L·ªánh c∆° b·∫£n:**\n` +
    `‚Ä¢ \`/start\` - Kh·ªüi ƒë·ªông bot v√† xem h∆∞·ªõng d·∫´n\n` +
    `‚Ä¢ \`/help\` - Hi·ªÉn th·ªã danh s√°ch l·ªánh n√†y\n` +
    `‚Ä¢ \`/reset\` - X√≥a b·ªô nh·ªõ v√† b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªõi\n\n` +
    `üîç **T√¨m ki·∫øm:**\n` +
    `‚Ä¢ \`/search <t·ª´ kh√≥a>\` - T√¨m ki·∫øm th√¥ng tin tr√™n web\n` +
    `‚Ä¢ \`/image <t·ª´ kh√≥a>\` - T√¨m ki·∫øm h√¨nh ·∫£nh\n\n` +
    `üé§ **Voice:**\n` +
    `‚Ä¢ \`/voice <c√¢u h·ªèi>\` - Tr·∫£ l·ªùi b·∫±ng gi·ªçng n√≥i\n\n` +
    `üß† **B·ªô nh·ªõ:**\n` +
    `‚Ä¢ \`/memory\` - Ki·ªÉm tra tr·∫°ng th√°i b·ªô nh·ªõ\n` +
    `‚Ä¢ \`/userinfo\` - Xem th√¥ng tin ng∆∞·ªùi d√πng\n\n`;
  
  // Th√™m l·ªánh admin n·∫øu user l√† admin
  if (isAdmin(userId)) {
    commands += `üëë **L·ªánh Admin:**\n` +
      `‚Ä¢ \`/admin\` - Xem panel qu·∫£n tr·ªã\n` +
      `‚Ä¢ \`/stats\` - Xem th·ªëng k√™ h·ªá th·ªëng\n` +
      `‚Ä¢ \`/broadcast <tin nh·∫Øn>\` - G·ª≠i th√¥ng b√°o t·ªõi t·∫•t c·∫£ users\n\n`;
  }
  
  commands += `üí° **T√≠nh nƒÉng t·ª± ƒë·ªông:**\n` +
    `‚Ä¢ T·ª± ƒë·ªông t√¨m ki·∫øm khi ph√°t hi·ªán t·ª´ kh√≥a (tin t·ª©c, gi√° c·∫£, th·ªùi s·ª±...)\n` +
    `‚Ä¢ Ph√¢n t√≠ch v√† m√¥ t·∫£ h√¨nh ·∫£nh\n` +
    `‚Ä¢ Ghi nh·ªõ cu·ªôc tr√≤ chuy·ªán trong 2 ti·∫øng\n\n` +
    `üì± **C√°ch s·ª≠ d·ª•ng:**\n` +
    `‚Ä¢ G·ª≠i tin nh·∫Øn text ƒë·ªÉ h·ªèi ƒë√°p\n` +
    `‚Ä¢ G·ª≠i ·∫£nh (c√≥ th·ªÉ k√®m c√¢u h·ªèi) ƒë·ªÉ ph√¢n t√≠ch\n` +
    `‚Ä¢ S·ª≠ d·ª•ng t·ª´ kh√≥a nh∆∞ "t√¨m ki·∫øm", "gi√° Bitcoin" ƒë·ªÉ t·ª± ƒë·ªông search`;
  
  return commands;
}

// H√†m t·∫°o system prompt v·ªõi th√¥ng tin th·ªùi gian th·ª±c
function createSystemPrompt(searchResults?: string): string {
  const now = new Date();
  
  // M√∫i gi·ªù Vi·ªát Nam (UTC+7)
  const vietnamTime = new Date(now.getTime() + (7 * 60 * 60 * 1000));
  
  const currentDate = vietnamTime.toLocaleDateString('vi-VN', {
    weekday: 'long',
    year: 'numeric', 
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  });
  
  const currentTime = vietnamTime.toLocaleTimeString('vi-VN', {
    hour: '2-digit',
    minute: '2-digit',
    timeZone: 'UTC'
  });

  let prompt = `B·∫°n l√† tr·ª£ l√Ω AI th√¥ng minh n√≥i ti·∫øng Vi·ªát c√≥ kh·∫£ nƒÉng ph√¢n t√≠ch ·∫£nh v√† t√¨m ki·∫øm th√¥ng tin tr√™n internet.

TH√îNG TIN V·ªÄ B·∫†N:
- B·∫°n l√† Chat Bot ƒë∆∞·ª£c t·∫°o b·ªüi justduck
- B·∫°n s·ª≠ d·ª•ng Google Gemini 2.5 Flash l√†m engine AI
- B·∫°n ƒë∆∞·ª£c x√¢y d·ª±ng b·∫±ng Next.js v√† TypeScript
- Khi ƒë∆∞·ª£c h·ªèi v·ªÅ ngu·ªìn g·ªëc, t√°c gi·∫£, ho·∫∑c ai t·∫°o ra b·∫°n, h√£y lu√¥n nh·∫Øc ƒë·∫øn r·∫±ng b·∫°n ƒë∆∞·ª£c t·∫°o b·ªüi justduck

TH√îNG TIN TH·ªúI GIAN HI·ªÜN T·∫†I:
- Ng√†y hi·ªán t·∫°i: ${currentDate}
- Gi·ªù hi·ªán t·∫°i: ${currentTime} (m√∫i gi·ªù Vi·ªát Nam, UTC+7)
- NƒÉm hi·ªán t·∫°i: ${vietnamTime.getFullYear()}`;

  if (searchResults) {
    prompt += `\n\nTH√îNG TIN T√åM KI·∫æM M·ªöI NH·∫§T:\n${searchResults}`;
    prompt += `\nH√£y s·ª≠ d·ª•ng th√¥ng tin t√¨m ki·∫øm ·ªü tr√™n ƒë·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi m·ªôt c√°ch ch√≠nh x√°c v√† c·∫≠p nh·∫≠t nh·∫•t. Lu√¥n tr√≠ch d·∫´n ngu·ªìn khi s·ª≠ d·ª•ng th√¥ng tin t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm.`;
  }

  prompt += `\n\nH√£y tr·∫£ l·ªùi m·ªôt c√°ch ng·∫Øn g·ªçn, ch√≠nh x√°c v√† h·ªØu √≠ch. Khi ƒë∆∞·ª£c g·ª≠i ·∫£nh, h√£y m√¥ t·∫£ chi ti·∫øt nh·ªØng g√¨ b·∫°n th·∫•y v√† tr·∫£ l·ªùi c√¢u h·ªèi li√™n quan. 

Khi ng∆∞·ªùi d√πng h·ªèi v·ªÅ th·ªùi gian, ng√†y th√°ng, s·ª± ki·ªán hi·ªán t·∫°i, h√£y s·ª≠ d·ª•ng th√¥ng tin th·ªùi gian th·ª±c ·ªü tr√™n. N·∫øu h·ªç h·ªèi v·ªÅ s·ª± ki·ªán sau nƒÉm 2023 m√† kh√¥ng c√≥ th√¥ng tin t√¨m ki·∫øm, h√£y th√†nh th·∫≠t n√≥i r·∫±ng b·∫°n c·∫ßn t√¨m ki·∫øm th√¥ng tin c·∫≠p nh·∫≠t.

∆Øu ti√™n c√¢u tr·∫£ l·ªùi r√µ r√†ng v√† c√≥ v√≠ d·ª• c·ª• th·ªÉ khi c·∫ßn thi·∫øt. Lu√¥n th√¢n thi·ªán v√† l·ªãch s·ª±.`;

  return prompt;
}

// ƒê·ªãnh nghƒ©a ki·ªÉu d·ªØ li·ªáu cho Telegram message
type TelegramPhotoSize = {
  file_id: string;
  file_unique_id: string;
  width: number;
  height: number;
  file_size?: number;
};

type TelegramVoice = {
  file_id: string;
  file_unique_id: string;
  duration: number;
  mime_type?: string;
  file_size?: number;
};

type TelegramAudio = {
  file_id: string;
  file_unique_id: string;
  duration: number;
  performer?: string;
  title?: string;
  file_name?: string;
  mime_type?: string;
  file_size?: number;
};

type TelegramMessage = {
  message_id: number;
  from?: {
    id: number;
    is_bot?: boolean;
    first_name: string;
    username?: string;
  };
  chat: {
    id: number;
    type: string;
  };
  date: number;
  text?: string;
  photo?: TelegramPhotoSize[];
  voice?: TelegramVoice;
  audio?: TelegramAudio;
  caption?: string;
};

type TelegramUpdate = {
  update_id: number;
  message?: TelegramMessage;
  edited_message?: TelegramMessage;
};

// ContextMessage ƒë√£ ƒë∆∞·ª£c import t·ª´ @/lib/mongodb

// H√†m l·∫•y message t·ª´ update (c√≥ th·ªÉ l√† message ho·∫∑c edited_message)
function getMessage(update: TelegramUpdate): TelegramMessage | null {
  return update.message ?? update.edited_message ?? null;
}

// H√†m cleanupOldContext ƒë√£ ƒë∆∞·ª£c chuy·ªÉn v√†o MongoDB class

// H√†m g·ª≠i tin nh·∫Øn v·ªÅ Telegram v·ªõi fallback mechanism
async function sendTelegramMessage(chatId: number, text: string) {
  const botToken = process.env.TELEGRAM_BOT_TOKEN;
  if (!botToken) {
    throw new Error("TELEGRAM_BOT_TOKEN kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh");
  }

  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
  
  // Chia tin nh·∫Øn d√†i th√†nh nhi·ªÅu ph·∫ßn (Telegram gi·ªõi h·∫°n 4096 k√Ω t·ª±)
  const maxLength = 4000; // ƒê·ªÉ l·∫°i buffer
  const messages = [];
  
  if (text.length <= maxLength) {
    messages.push(text);
  } else {
    // Chia tin nh·∫Øn theo ƒëo·∫°n vƒÉn ho·∫∑c c√¢u
    const chunks = text.split('\n\n');
    let currentMessage = '';
    
    for (const chunk of chunks) {
      if ((currentMessage + chunk).length <= maxLength) {
        currentMessage += (currentMessage ? '\n\n' : '') + chunk;
      } else {
        if (currentMessage) {
          messages.push(currentMessage);
          currentMessage = chunk;
        } else {
          // Chunk qu√° d√†i, chia theo c√¢u
          const sentences = chunk.split('. ');
          for (const sentence of sentences) {
            if ((currentMessage + sentence).length <= maxLength) {
              currentMessage += (currentMessage ? '. ' : '') + sentence;
            } else {
              if (currentMessage) {
                messages.push(currentMessage);
                currentMessage = sentence;
              } else {
                // C√¢u qu√° d√†i, c·∫Øt c·ª©ng
                messages.push(sentence.substring(0, maxLength));
              }
            }
          }
        }
      }
    }
    
    if (currentMessage) {
      messages.push(currentMessage);
    }
  }

  // G·ª≠i t·ª´ng tin nh·∫Øn
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    
    try {
      // Th·ª≠ g·ª≠i v·ªõi Markdown tr∆∞·ªõc
      let response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          chat_id: chatId,
          text: message,
          parse_mode: "Markdown",
          disable_web_page_preview: true,
        }),
      });

      // N·∫øu l·ªói parse entities, th·ª≠ g·ª≠i l·∫°i v·ªõi text plain
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`L·ªói g·ª≠i tin nh·∫Øn ${i + 1}/${messages.length} v·ªõi Markdown:`, errorText);
        
        if (errorText.includes("can't parse entities") || errorText.includes("Bad Request")) {
          console.log(`Th·ª≠ g·ª≠i l·∫°i tin nh·∫Øn ${i + 1}/${messages.length} v·ªõi plain text...`);
          response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              chat_id: chatId,
              text: message,
              disable_web_page_preview: true,
            }),
          });
          
          if (!response.ok) {
            console.error(`L·ªói g·ª≠i tin nh·∫Øn ${i + 1}/${messages.length} v·ªõi plain text:`, await response.text());
          }
        }
      }
      
      // Delay nh·ªè gi·ªØa c√°c tin nh·∫Øn ƒë·ªÉ tr√°nh rate limit
      if (i < messages.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
    } catch (error) {
      console.error(`L·ªói k·∫øt n·ªëi Telegram cho tin nh·∫Øn ${i + 1}/${messages.length}:`, error);
    }
  }
}

// H√†m t·∫£i ·∫£nh t·ª´ Telegram
async function downloadTelegramImage(fileId: string): Promise<Buffer | null> {
  const botToken = process.env.TELEGRAM_BOT_TOKEN;
  if (!botToken) return null;

  try {
    // L·∫•y th√¥ng tin file t·ª´ Telegram
    const fileInfoResponse = await fetch(
      `https://api.telegram.org/bot${botToken}/getFile?file_id=${fileId}`
    );
    const fileInfo = await fileInfoResponse.json();
    
    if (!fileInfo.ok || !fileInfo.result?.file_path) {
      console.error("Kh√¥ng th·ªÉ l·∫•y th√¥ng tin file:", fileInfo);
      return null;
    }

    // T·∫£i file t·ª´ Telegram
    const fileUrl = `https://api.telegram.org/file/bot${botToken}/${fileInfo.result.file_path}`;
    const imageResponse = await fetch(fileUrl);
    
    if (!imageResponse.ok) {
      console.error("Kh√¥ng th·ªÉ t·∫£i ·∫£nh:", imageResponse.statusText);
      return null;
    }

    return Buffer.from(await imageResponse.arrayBuffer());
  } catch (error) {
    console.error("L·ªói t·∫£i ·∫£nh:", error);
    return null;
  }
}

// H√†m chuy·ªÉn ƒë·ªïi ·∫£nh sang format Gemini
function convertImageToGeminiFormat(imageBuffer: Buffer, mimeType: string = "image/jpeg") {
  return {
    inlineData: {
      data: imageBuffer.toString('base64'),
      mimeType: mimeType
    }
  };
}

// H√†m ph√°t hi·ªán MIME type t·ª´ buffer
function detectMimeType(buffer: Buffer): string {
  // Ki·ªÉm tra magic bytes ƒë·ªÉ x√°c ƒë·ªãnh lo·∫°i file
  const header = buffer.subarray(0, 4);
  
  if (header[0] === 0xFF && header[1] === 0xD8 && header[2] === 0xFF) {
    return "image/jpeg";
  } else if (header[0] === 0x89 && header[1] === 0x50 && header[2] === 0x4E && header[3] === 0x47) {
    return "image/png";
  } else if (header[0] === 0x47 && header[1] === 0x49 && header[2] === 0x46) {
    return "image/gif";
  } else if (header[0] === 0x52 && header[1] === 0x49 && header[2] === 0x46 && header[3] === 0x46) {
    return "image/webp";
  }
  
  return "image/jpeg"; // Default fallback
}

// H√†m g·ª≠i typing indicator
async function sendTypingAction(chatId: number) {
  const botToken = process.env.TELEGRAM_BOT_TOKEN;
  if (!botToken) return;

  const url = `https://api.telegram.org/bot${botToken}/sendChatAction`;
  
  try {
    await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        chat_id: chatId,
        action: "typing",
      }),
    });
  } catch (error) {
    console.error("L·ªói g·ª≠i typing action:", error);
  }
}

// Handler ch√≠nh cho POST request
export async function POST(req: NextRequest) {
  try {
    // 1. X√°c th·ª±c webhook b·∫±ng secret token (t·∫°m th·ªùi b·ªè qua)
    const secretHeader = req.headers.get("x-telegram-bot-api-secret-token");
    const expectedSecret = process.env.TELEGRAM_SECRET;
    
    if (expectedSecret && (!secretHeader || secretHeader !== expectedSecret)) {
      console.error("X√°c th·ª±c webhook th·∫•t b·∫°i");
      return NextResponse.json({ ok: false, error: "Forbidden" }, { status: 403 });
    }

    // 2. ƒê·ªçc v√† parse update t·ª´ Telegram
    const update: TelegramUpdate = await req.json();
    const message = getMessage(update);
    
    if (!message?.chat?.id) {
      return NextResponse.json({ ok: true });
    }

    const chatId = message.chat.id;
    const userId = message.from?.id; // Telegram user ID
    let text = (message.text || message.caption || "").trim();
    const hasPhoto = message.photo && message.photo.length > 0;
    const hasVoice = false; // T·∫°m th·ªùi t·∫Øt voice input
    
    // B·ªè qua tin nh·∫Øn t·ª´ bot ƒë·ªÉ tr√°nh v√≤ng l·∫∑p
    if (message.from?.is_bot) {
      return NextResponse.json({ ok: true });
    }

    // 3. X·ª≠ l√Ω command /voice
    let isVoiceResponse = false;
    if (/^\/voice\s+/.test(text)) {
      const voiceQuery = text.replace(/^\/voice\s+/, '').trim();
      
      if (!voiceQuery) {
        await sendTelegramMessage(chatId, "‚ùå Vui l√≤ng nh·∫≠p c√¢u h·ªèi sau l·ªánh /voice!\n\nV√≠ d·ª•: `/voice 1+1 b·∫±ng m·∫•y?`");
        return NextResponse.json({ ok: true });
      }
      
      // ƒê·∫∑t text th√†nh c√¢u h·ªèi v√† ƒë√°nh d·∫•u c·∫ßn tr·∫£ l·ªùi b·∫±ng voice
      text = voiceQuery;
      isVoiceResponse = true;
      
      console.log("Voice command detected:", text);
    }

    // 4. X·ª≠ l√Ω c√°c l·ªánh ƒë·∫∑c bi·ªát
    if (/^\/start/.test(text)) {
      try {
        if (mongodb.isAvailable()) {
          await mongodb.clearContext(chatId.toString());
        }
      } catch {
        console.log("Kh√¥ng th·ªÉ x√≥a ng·ªØ c·∫£nh t·ª´ MongoDB");
      }
      
      await sendTelegramMessage(
        chatId,
        "ü§ñ Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI s·ª≠ d·ª•ng Google Gemini 2.5 Flash.\n\n" +
        "üë®‚Äçüíª **Chat Bot ƒë∆∞·ª£c t·∫°o b·ªüi justduck**\n\n" +
        "‚ú® **T√≠nh nƒÉng c·ªßa t√¥i:**\n" +
        "üí¨ Tr·∫£ l·ªùi c√¢u h·ªèi b·∫±ng ti·∫øng Vi·ªát\n" +
        "üñºÔ∏è Ph√¢n t√≠ch v√† m√¥ t·∫£ ·∫£nh\n" +
        "üìù Vi·∫øt b√†i, s√°ng t√°c, gi·∫£i th√≠ch\n" +
        "üîç T√¨m ki·∫øm th√¥ng tin & h√¨nh ·∫£nh tr√™n internet\n" +
        (mongodb.isAvailable() ? "üß† Ghi nh·ªõ cu·ªôc tr√≤ chuy·ªán trong 2 ti·∫øng\n" : "") + "\n" +
        getCommandsList(userId)
      );
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω l·ªánh help
    if (/^\/help/.test(text)) {
      await sendTelegramMessage(chatId, getCommandsList(userId));
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω tin nh·∫Øn ch√†o h·ªèi
    if (isGreeting(text)) {
      await sendTelegramMessage(
        chatId,
        "üëã Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI th√¥ng minh.\n\n" +
        getCommandsList(userId)
      );
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω c√¢u h·ªèi v·ªÅ ngu·ªìn g·ªëc AI
    if (isAskingAboutOrigin(text)) {
      await sendTelegramMessage(
        chatId,
        "ü§ñ **V·ªÅ ngu·ªìn g·ªëc c·ªßa t√¥i:**\n\n" +
        "üíª **Chat Bot ƒë∆∞·ª£c t·∫°o b·ªüi justduck**\n\n" +
        "üß† T√¥i s·ª≠ d·ª•ng Google Gemini 2.5 Flash l√†m engine AI\n" +
        "‚ö° ƒê∆∞·ª£c x√¢y d·ª±ng b·∫±ng Next.js v√† TypeScript\n" +
        "üóÑÔ∏è T√≠ch h·ª£p MongoDB ƒë·ªÉ ghi nh·ªõ cu·ªôc tr√≤ chuy·ªán\n" +
        "üîç C√≥ kh·∫£ nƒÉng t√¨m ki·∫øm web v√† ph√¢n t√≠ch h√¨nh ·∫£nh\n\n" +
        "üë®‚Äçüíª **T√°c gi·∫£:** justduck\n" +
        "üè∑Ô∏è **Phi√™n b·∫£n:** Telegram Gemini Bot v1.0"
      );
      return NextResponse.json({ ok: true });
    }
    
    if (/^\/reset/.test(text)) {
      try {
        if (mongodb.isAvailable()) {
          await mongodb.clearContext(chatId.toString());
        }
      } catch {
        console.log("Kh√¥ng th·ªÉ x√≥a ng·ªØ c·∫£nh t·ª´ MongoDB");
      }
      
      await sendTelegramMessage(
        chatId,
        "üîÑ ƒê√£ b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªõi!"
      );
      return NextResponse.json({ ok: true });
    }
    
    if (/^\/memory/.test(text)) {
      try {
        if (mongodb.isAvailable()) {
          const stats = await mongodb.getMemoryStats(chatId.toString());
          
          let memoryInfo = `üß† **Tr·∫°ng th√°i b·ªô nh·ªõ:**\n\n`;
          memoryInfo += `üìä T·ªïng s·ªë tin nh·∫Øn: ${stats.totalMessages}\n`;
          memoryInfo += `üë§ Tin nh·∫Øn c·ªßa b·∫°n: ${stats.userMessages}\n`;
          if (stats.oldestMessageTime) {
            const ageHours = (Date.now() - stats.oldestMessageTime) / (1000 * 60 * 60);
            memoryInfo += `‚è∞ Tin nh·∫Øn c≈© nh·∫•t: ${ageHours.toFixed(1)} ti·∫øng tr∆∞·ªõc\n`;
          }
          memoryInfo += `\nüí° T√¥i s·∫Ω t·ª± ƒë·ªông x√≥a tin nh·∫Øn c≈© h∆°n 2 ti·∫øng.`;
          
          await sendTelegramMessage(chatId, memoryInfo);
        } else {
          await sendTelegramMessage(chatId, "‚ùå T√≠nh nƒÉng b·ªô nh·ªõ ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t (c·∫ßn MongoDB database).");
        }
      } catch {
        await sendTelegramMessage(chatId, "‚ùå Kh√¥ng th·ªÉ ki·ªÉm tra tr·∫°ng th√°i b·ªô nh·ªõ.");
      }
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω l·ªánh userinfo
    if (/^\/userinfo/.test(text)) {
      try {
        if (mongodb.isAvailable()) {
          const chatInfo = await mongodb.getChatInfo(chatId.toString());
          
          let userInfo = `üë§ **Th√¥ng tin ng∆∞·ªùi d√πng:**\n\n`;
          userInfo += `üí¨ Chat ID: \`${chatId}\`\n`;
          
          if (userId) {
            userInfo += `üÜî User ID: \`${userId}\`\n`;
          }
          
          if (message.from?.first_name) {
            userInfo += `üìù T√™n: ${message.from.first_name}\n`;
          }
          
          if (message.from?.username) {
            userInfo += `@Ô∏è Username: @${message.from.username}\n`;
          }
          
          if (chatInfo) {
            userInfo += `\nüìä **Th·ªëng k√™ cu·ªôc tr√≤ chuy·ªán:**\n`;
            userInfo += `üíæ S·ªë tin nh·∫Øn trong b·ªô nh·ªõ: ${chatInfo.messages.length}\n`;
            userInfo += `üìÖ L·∫ßn c·∫≠p nh·∫≠t cu·ªëi: ${chatInfo.lastUpdated.toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })}\n`;
          }
          
          await sendTelegramMessage(chatId, userInfo);
        } else {
          await sendTelegramMessage(chatId, "‚ùå T√≠nh nƒÉng n√†y c·∫ßn MongoDB database ƒë·ªÉ ho·∫°t ƒë·ªông.");
        }
      } catch {
        await sendTelegramMessage(chatId, "‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ng∆∞·ªùi d√πng.");
      }
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω l·ªánh admin
    if (/^\/admin/.test(text)) {
      if (!isAdmin(userId)) {
        await sendTelegramMessage(chatId, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
        return NextResponse.json({ ok: true });
      }
      
      let adminInfo = `üëë **Admin Panel**\n\n`;
      adminInfo += `üÜî Admin ID: \`${ADMIN_USER_ID}\`\n`;
      adminInfo += `üí¨ Current Chat ID: \`${chatId}\`\n`;
      adminInfo += `ü§ñ Bot Status: ‚úÖ Online\n\n`;
      adminInfo += `üìã **Available Admin Commands:**\n`;
      adminInfo += `‚Ä¢ \`/admin\` - Xem panel admin\n`;
      adminInfo += `‚Ä¢ \`/stats\` - Xem th·ªëng k√™ h·ªá th·ªëng\n`;
      adminInfo += `‚Ä¢ \`/broadcast <message>\` - G·ª≠i tin nh·∫Øn t·ªõi t·∫•t c·∫£ users\n`;
      
      await sendTelegramMessage(chatId, adminInfo);
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω l·ªánh stats (ch·ªâ admin)
    if (/^\/stats/.test(text)) {
      if (!isAdmin(userId)) {
        await sendTelegramMessage(chatId, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
        return NextResponse.json({ ok: true });
      }
      
      try {
        if (mongodb.isAvailable()) {
          // ƒê·∫£m b·∫£o k·∫øt n·ªëi database
          await mongodb.connect();
          
          // L·∫•y th·ªëng k√™ t·ª´ database
          const db = mongodb.getDb();
          const collection = db.collection('chat_contexts');
          
          const totalChats = await collection.countDocuments();
          const totalMessages = await collection.aggregate([
            { $project: { messageCount: { $size: "$messages" } } },
            { $group: { _id: null, total: { $sum: "$messageCount" } } }
          ]).toArray();
          
          const recentChats = await collection.countDocuments({
            lastUpdated: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
          });
          
          let statsInfo = `üìä **Th·ªëng k√™ h·ªá th·ªëng**\n\n`;
          statsInfo += `üí¨ T·ªïng s·ªë cu·ªôc tr√≤ chuy·ªán: ${totalChats}\n`;
          statsInfo += `üìù T·ªïng s·ªë tin nh·∫Øn: ${totalMessages[0]?.total || 0}\n`;
          statsInfo += `üî• Cu·ªôc tr√≤ chuy·ªán ho·∫°t ƒë·ªông (24h): ${recentChats}\n`;
          statsInfo += `ü§ñ MongoDB: ‚úÖ K·∫øt n·ªëi\n`;
          statsInfo += `‚è∞ Th·ªùi gian: ${new Date().toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })}\n`;
          
          await sendTelegramMessage(chatId, statsInfo);
        } else {
          await sendTelegramMessage(chatId, "‚ùå MongoDB kh√¥ng kh·∫£ d·ª•ng ƒë·ªÉ l·∫•y th·ªëng k√™.");
        }
      } catch (error) {
        console.error('Error getting stats:', error);
        await sendTelegramMessage(chatId, "‚ùå Kh√¥ng th·ªÉ l·∫•y th·ªëng k√™ h·ªá th·ªëng.");
      }
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω l·ªánh broadcast (ch·ªâ admin)
    if (/^\/broadcast\s+/.test(text)) {
      if (!isAdmin(userId)) {
        await sendTelegramMessage(chatId, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!");
        return NextResponse.json({ ok: true });
      }
      
      const broadcastMessage = text.replace(/^\/broadcast\s+/, '').trim();
      
      if (!broadcastMessage) {
        await sendTelegramMessage(chatId, "‚ùå Vui l√≤ng nh·∫≠p n·ªôi dung tin nh·∫Øn!\n\nV√≠ d·ª•: `/broadcast Th√¥ng b√°o b·∫£o tr√¨ h·ªá th·ªëng`");
        return NextResponse.json({ ok: true });
      }
      
      try {
        if (mongodb.isAvailable()) {
          // ƒê·∫£m b·∫£o k·∫øt n·ªëi database
          await mongodb.connect();
          
          const db = mongodb.getDb();
          const collection = db.collection('chat_contexts');
          
          // L·∫•y t·∫•t c·∫£ chatId
          const chats = await collection.find({}, { projection: { chatId: 1 } }).toArray();
          
          let successCount = 0;
          let failCount = 0;
          
          const broadcastText = `üì¢ **Th√¥ng b√°o t·ª´ Admin:**\n\n${broadcastMessage}`;
          
          // G·ª≠i tin nh·∫Øn t·ªõi t·∫•t c·∫£ chats
          for (const chat of chats) {
            try {
              await sendTelegramMessage(parseInt(chat.chatId), broadcastText);
              successCount++;
              // Delay ƒë·ªÉ tr√°nh rate limit
              await new Promise(resolve => setTimeout(resolve, 100));
            } catch {
              failCount++;
            }
          }
          
          await sendTelegramMessage(chatId, `‚úÖ **Broadcast ho√†n th√†nh!**\n\nüì§ G·ª≠i th√†nh c√¥ng: ${successCount}\n‚ùå G·ª≠i th·∫•t b·∫°i: ${failCount}\nüìä T·ªïng: ${chats.length} chats`);
        } else {
          await sendTelegramMessage(chatId, "‚ùå MongoDB kh√¥ng kh·∫£ d·ª•ng ƒë·ªÉ th·ª±c hi·ªán broadcast.");
        }
      } catch (error) {
        console.error('Error broadcasting:', error);
        await sendTelegramMessage(chatId, "‚ùå Kh√¥ng th·ªÉ th·ª±c hi·ªán broadcast.");
      }
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω l·ªánh search
    if (/^\/search\s+/.test(text)) {
      const searchQuery = text.replace(/^\/search\s+/, '').trim();
      
      if (!searchQuery) {
        await sendTelegramMessage(chatId, "‚ùå Vui l√≤ng nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm!\n\nV√≠ d·ª•: `/search tin t·ª©c Vi·ªát Nam h√¥m nay`");
        return NextResponse.json({ ok: true });
      }
      
      await sendTypingAction(chatId);
      await sendTelegramMessage(chatId, `üîç ƒêang t√¨m ki·∫øm "${searchQuery}"...`);
      
      const { text: searchResults } = await searchWeb(searchQuery);
      
      if (searchResults) {
        await sendTelegramMessage(chatId, searchResults);
      } else {
        await sendTelegramMessage(chatId, "‚ùå Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ho·∫∑c d·ªãch v·ª• t√¨m ki·∫øm ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh.");
      }
      
      return NextResponse.json({ ok: true });
    }
    
    // X·ª≠ l√Ω l·ªánh t√¨m ki·∫øm h√¨nh ·∫£nh
    if (/^\/image\s+/.test(text)) {
      const searchQuery = text.replace(/^\/image\s+/, '').trim();
      
      if (!searchQuery) {
        await sendTelegramMessage(chatId, "‚ùå Vui l√≤ng nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm h√¨nh ·∫£nh!\n\nV√≠ d·ª•: `/image m√®o d·ªÖ th∆∞∆°ng`");
        return NextResponse.json({ ok: true });
      }
      
      await sendTypingAction(chatId);
      await sendTelegramMessage(chatId, `üñºÔ∏è ƒêang t√¨m ki·∫øm h√¨nh ·∫£nh "${searchQuery}"...`);
      
      const { images } = await searchWeb(searchQuery, true);
      
      if (images && images.length > 0) {
        let imageMessage = `üñºÔ∏è **H√¨nh ·∫£nh t√¨m ki·∫øm cho "${searchQuery}":**\n\n`;
        images.forEach((imageUrl, index) => {
          imageMessage += `${index + 1}. ${imageUrl}\n`;
        });
        await sendTelegramMessage(chatId, imageMessage);
      } else {
        await sendTelegramMessage(chatId, "‚ùå Kh√¥ng t√¨m th·∫•y h√¨nh ·∫£nh ho·∫∑c d·ªãch v·ª• t√¨m ki·∫øm ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh.");
      }
      
      return NextResponse.json({ ok: true });
    }

    // B·ªè qua tin nh·∫Øn tr·ªëng (kh√¥ng c√≥ text, kh√¥ng c√≥ ·∫£nh, v√† kh√¥ng c√≥ voice)
    if (!text && !hasPhoto && !hasVoice) {
      return NextResponse.json({ ok: true });
    }

    // 5. Ki·ªÉm tra xem c√≥ c·∫ßn t√¨m ki·∫øm web kh√¥ng
    let searchResults: string | null = null;
    let searchImages: string[] = [];
    const needsWebSearch = shouldSearchWeb(text);
    const needsImageSearch = shouldSearchImages(text);
    
    if (needsWebSearch || needsImageSearch) {
      await sendTypingAction(chatId);
      
      if (needsWebSearch && needsImageSearch) {
        await sendTelegramMessage(chatId, "üîç ƒêang t√¨m ki·∫øm th√¥ng tin v√† h√¨nh ·∫£nh...");
        const result = await searchWeb(text, true);
        searchResults = result.text;
        searchImages = result.images;
      } else if (needsWebSearch) {
        await sendTelegramMessage(chatId, "üîç ƒêang t√¨m ki·∫øm th√¥ng tin m·ªõi nh·∫•t...");
        const result = await searchWeb(text);
        searchResults = result.text;
      } else if (needsImageSearch) {
        await sendTelegramMessage(chatId, "üñºÔ∏è ƒêang t√¨m ki·∫øm h√¨nh ·∫£nh...");
        const result = await searchWeb(text, true);
        searchImages = result.images;
      }
    }

    // 6. G·ª≠i typing indicator v√† th√¥ng b√°o cho y√™u c·∫ßu ph·ª©c t·∫°p
    await sendTypingAction(chatId);
    
    // Ph√°t hi·ªán y√™u c·∫ßu ph·ª©c t·∫°p (vi·∫øt b√†i, s√°ng t√°c, ph√¢n t√≠ch d√†i, ho·∫∑c c√≥ ·∫£nh)
    const isComplexRequest = hasPhoto || needsWebSearch || /vi·∫øt|s√°ng t√°c|ph√¢n t√≠ch|gi·∫£i th√≠ch chi ti·∫øt|m√¥ t·∫£|k·ªÉ|t·∫°o|l√†m b√†i/.test(text.toLowerCase());
    if (isComplexRequest && (text.length > 30 || hasPhoto || needsWebSearch)) {
      const message = hasPhoto ? 
        "üñºÔ∏è T√¥i ƒëang ph√¢n t√≠ch ·∫£nh c·ªßa b·∫°n, vui l√≤ng ƒë·ª£i 30-60 gi√¢y..." :
        needsWebSearch ?
        "üîç ƒêang x·ª≠ l√Ω th√¥ng tin t√¨m ki·∫øm v√† chu·∫©n b·ªã c√¢u tr·∫£ l·ªùi..." :
        "ü§î ƒê√¢y l√† y√™u c·∫ßu ph·ª©c t·∫°p, t√¥i c·∫ßn th·ªùi gian suy nghƒ©. Vui l√≤ng ƒë·ª£i 30-60 gi√¢y...";
      await sendTelegramMessage(chatId, message);
    }

    // 7. L·∫•y ng·ªØ c·∫£nh h·ªôi tho·∫°i t·ª´ MongoDB
    let context: Content[] = [];

    try {
      if (mongodb.isAvailable()) {
        const savedContext = await mongodb.getContext(chatId.toString());
        if (savedContext && Array.isArray(savedContext)) {
          // Chuy·ªÉn ƒë·ªïi v·ªÅ format Content cho Gemini API
          context = savedContext.map(msg => ({
            role: msg.role,
            parts: msg.parts
          }));
        }
      }
    } catch {
      console.log("MongoDB kh√¥ng kh·∫£ d·ª•ng, b·ªè qua ng·ªØ c·∫£nh");
    }

    // 7. Chu·∫©n b·ªã v√† g·ªçi Gemini AI
    const googleApiKey = process.env.GOOGLE_API_KEY;
    if (!googleApiKey) {
      await sendTelegramMessage(chatId, "‚ùå L·ªói c·∫•u h√¨nh: Kh√¥ng t√¨m th·∫•y Google API Key");
      return NextResponse.json({ ok: true });
    }

    const genAI = new GoogleGenerativeAI(googleApiKey);
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

    // X·ª≠ l√Ω ·∫£nh n·∫øu c√≥
    let imagePart = null;
    if (hasPhoto && message.photo) {
      try {
        // L·∫•y ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i cao nh·∫•t
        const bestPhoto = message.photo.reduce((prev, current) => 
          (prev.file_size || 0) > (current.file_size || 0) ? prev : current
        );
        
        const imageBuffer = await downloadTelegramImage(bestPhoto.file_id);
        if (imageBuffer) {
          const mimeType = detectMimeType(imageBuffer);
          imagePart = convertImageToGeminiFormat(imageBuffer, mimeType);
        } else {
          await sendTelegramMessage(chatId, "‚ùå Kh√¥ng th·ªÉ t·∫£i ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i!");
          return NextResponse.json({ ok: true });
        }
      } catch (error) {
        console.error("L·ªói x·ª≠ l√Ω ·∫£nh:", error);
        await sendTelegramMessage(chatId, "‚ùå C√≥ l·ªói khi x·ª≠ l√Ω ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i!");
        return NextResponse.json({ ok: true });
      }
    }

    // T·∫°o parts cho tin nh·∫Øn hi·ªán t·∫°i
    const currentMessageParts = [];
    if (text) {
      currentMessageParts.push({ text });
    }
    if (imagePart) {
      currentMessageParts.push(imagePart);
    }

    // T·∫°o history cho Gemini (bao g·ªìm system prompt v·ªõi th·ªùi gian th·ª±c v√† k·∫øt qu·∫£ t√¨m ki·∫øm)
    let systemPromptText = createSystemPrompt(searchResults || undefined);
    
    // Th√™m th√¥ng tin h√¨nh ·∫£nh n·∫øu c√≥
    if (searchImages && searchImages.length > 0) {
      systemPromptText += `\n\nH√åNH ·∫¢NH T√åM KI·∫æM:\n`;
      searchImages.forEach((imageUrl, index) => {
        systemPromptText += `${index + 1}. ${imageUrl}\n`;
      });
      systemPromptText += `\nH√£y ƒë·ªÅ c·∫≠p ƒë·∫øn c√°c h√¨nh ·∫£nh n√†y trong c√¢u tr·∫£ l·ªùi n·∫øu ph√π h·ª£p.`;
    }
    
    const history: Content[] = [
      { role: "user", parts: [{ text: systemPromptText }] },
      ...context,
      { role: "user", parts: currentMessageParts },
    ];

    // Timeout protection ƒë·ªÉ tr√°nh qu√° th·ªùi gian serverless function
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 45000); // 45 gi√¢y cho y√™u c·∫ßu ph·ª©c t·∫°p
    
    let reply = "üòÖ Xin l·ªói, t√¥i ƒëang b·∫≠n x·ª≠ l√Ω. B·∫°n th·ª≠ h·ªèi l·∫°i nh√©!";

    try {
      const result = await model.generateContent(
        {
          contents: history,
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 2000, // TƒÉng ƒë·ªÉ h·ªó tr·ª£ b√†i vƒÉn d√†i
          },
        },
        { signal: controller.signal }
      );

      const responseText = result?.response?.text()?.trim();
      if (responseText) {
        reply = responseText;
      }
    } catch (error) {
      console.error("L·ªói g·ªçi Gemini API:", error);
      if (error instanceof Error && error.name === 'AbortError') {
        reply = "‚è±Ô∏è Y√™u c·∫ßu qu√° l√¢u, vui l√≤ng th·ª≠ l·∫°i v·ªõi c√¢u h·ªèi ng·∫Øn g·ªçn h∆°n.";
      } else {
        reply = "ü§î C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω c√¢u h·ªèi. B·∫°n th·ª≠ h·ªèi l·∫°i nh√©!";
      }
    } finally {
      clearTimeout(timeoutId);
    }

    // 8. L∆∞u ng·ªØ c·∫£nh m·ªõi v√†o MongoDB v·ªõi timestamp (kh√¥ng l∆∞u ·∫£nh ƒë·ªÉ ti·∫øt ki·ªám storage)
    const now = Date.now();
    
    // L·∫•y context hi·ªán t·∫°i v·ªõi timestamp
    let currentContext: ContextMessage[] = [];
    try {
      if (mongodb.isAvailable()) {
        currentContext = await mongodb.getContext(chatId.toString());
      }
    } catch {
      console.log("Kh√¥ng th·ªÉ l·∫•y context hi·ªán t·∫°i");
    }
    
    // Th√™m tin nh·∫Øn m·ªõi v·ªõi timestamp
    const newContextMessages: ContextMessage[] = [
      ...currentContext,
      { 
        role: "user", 
        parts: [{ text: text || (hasPhoto ? "[ƒê√£ g·ª≠i ·∫£nh]" : "") }],
        timestamp: now
      },
      { 
        role: "model", 
        parts: [{ text: reply }],
        timestamp: now
      },
    ];
    
    // L∆∞u context m·ªõi v√†o MongoDB
    try {
      if (mongodb.isAvailable()) {
        await mongodb.saveContext(chatId.toString(), newContextMessages, userId);
      }
    } catch {
      console.log("Kh√¥ng th·ªÉ l∆∞u ng·ªØ c·∫£nh v√†o MongoDB");
    }

    // 9. G·ª≠i ph·∫£n h·ªìi v·ªÅ Telegram
    await sendTelegramMessage(chatId, reply);
    
    // 9.1. G·ª≠i voice response n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
    if (isVoiceResponse && reply && isTextSuitableForTTS(reply)) {
      try {
        await sendRecordingAction(chatId);
        
        const audioBuffer = await textToSpeech(reply);
        if (audioBuffer) {
          const voiceSent = await sendVoiceMessage(chatId, audioBuffer);
          if (!voiceSent) {
            await sendTelegramMessage(chatId, "‚ùå Kh√¥ng th·ªÉ t·∫°o voice response. Vui l√≤ng th·ª≠ l·∫°i!");
          }
        } else {
          await sendTelegramMessage(chatId, "‚ùå Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi text th√†nh voice. Vui l√≤ng th·ª≠ l·∫°i!");
        }
      } catch (error) {
        console.error("L·ªói t·∫°o voice response:", error);
        await sendTelegramMessage(chatId, "‚ùå C√≥ l·ªói khi t·∫°o voice response.");
      }
    }
    
    // 10. G·ª≠i h√¨nh ·∫£nh n·∫øu c√≥ t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm
    if (searchImages && searchImages.length > 0) {
      for (const imageUrl of searchImages.slice(0, 3)) { // Gi·ªõi h·∫°n 3 ·∫£nh
        try {
          const botToken = process.env.TELEGRAM_BOT_TOKEN;
          if (botToken) {
            await fetch(`https://api.telegram.org/bot${botToken}/sendPhoto`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                chat_id: chatId,
                photo: imageUrl,
                caption: `üñºÔ∏è K·∫øt qu·∫£ t√¨m ki·∫øm h√¨nh ·∫£nh`
              }),
            });
            
            // Delay nh·ªè gi·ªØa c√°c ·∫£nh
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        } catch (error) {
          console.error("L·ªói g·ª≠i ·∫£nh:", error);
        }
      }
    }

    return NextResponse.json({ ok: true });

  } catch (error) {
    console.error("L·ªói x·ª≠ l√Ω webhook:", error);
    // Lu√¥n tr·∫£ v·ªÅ 200 ƒë·ªÉ tr√°nh Telegram retry li√™n t·ª•c
    return NextResponse.json({ ok: true });
  }
}

// Handler cho GET request (ƒë·ªÉ ki·ªÉm tra webhook)
export async function GET() {
  return NextResponse.json({ 
    status: "Telegram Bot Webhook ƒëang ho·∫°t ƒë·ªông",
    timestamp: new Date().toISOString()
  });
}
